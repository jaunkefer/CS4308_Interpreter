/*
    CS4308 Interpreter -- Parser
    Project 2nd deliverable.

    Authors:
        Joshua Unkefer
        Eric Bell
        Farid Khan
*/
package cs4308_interpreter;

import java.util.ArrayList;
import java.util.Stack;

public class ParserClass 
{    
    //Global variables
    boolean cont = true;
    boolean leading_zero = false;
    boolean negative = false;
    
    int counter  = 0;
    Stack<String> parenthesis_closed = new Stack<String>();
    
    public void syntax(ArrayList<String> x)
    //Precondition:
    //Postcondition: A for loop reads the token list generated by the scanner, 
    //ensuring proper syntax ordering. Method calls are made to individual methods
    //confirming the syntactical correctness of each token in relation to the 
    //tokens surrounding it. If the tokens are found to be in an impossible order,
    //an error message is delivered to the console screen and the loop ends. If 
    //the syntax is correct, a print is sent to the console notifying the user of
    //syntactical correctness.
    {
        for(int i = 0; i < x.size(); i++)
        {                 
            try
            {
                if(x.get(i).contains("VARIABLE"))
                {
                    token_variable(x);
                    if(!cont)
                        break;               
                }

                else if(x.get(i).contains("EQUALS"))
                {
                    token_equals(x);
                    if(!cont)
                        break;
                }

                else if(x.get(i).contains("MULTIPLY")||x.get(i).contains("DIVIDE")
                        ||x.get(i).contains("PLUS"))
                {
                    token_operator(x);
                    if(!cont)
                        break;
                }

                else if(x.get(i).contains("MINUS"))
                {
                    token_minus(x);
                    if(!cont)
                        break;
                }

                else if(x.get(i).contains("INTEGER"))
                {
                    token_integer(x);
                    if(!cont)
                        break;
                }

                else if(x.get(i).contains("LEFT_PARENTHESIS"))
                {
                    token_left_parenthesis(x);
                    if(!cont)
                        break;
                }

                else if(x.get(i).contains("RIGHT_PARENTHESIS"))
                {
                    token_right_parenthesis(x);
                    if(!cont)
                        break;
                }

                else if(x.get(i).contains("NEW LINE"))
                {
                    token_new_line(x);
                    if(!cont)
                        break;
                }
                
                else if(x.get(i).contains("ZERO"))
                {
                    token_zero(x);
                    if(!cont)
                        break;
                }

                else
                {
                    System.out.println("Unrecognizeable token...");
                    break;
                }                
                 
                if(i + 1 == x.size() && cont == true && parenthesis_closed.isEmpty())
                    System.out.println("\nSyntax is correct...\n");
                
                else if(i + 1 == x.size() && cont == true && !parenthesis_closed.isEmpty())
                    System.out.println("\nMissing closing parenthesis...");
            } 
            
            catch(Exception e)
            {
                System.out.println("Error: " + e.getMessage());
            }
        }
    } 
    
    public void token_variable(ArrayList<String> x)
    //Precondition:
    //Postconditiion: Ensures the legality of the token ordering in relation to 
    //the 'VARIABLE' token.
    {
        if(counter + 1 < x.size() && !x.get(counter + 1).contains("EQUALS"))
        {
            System.out.println("\nA variable declaration must be followed by an"
                    + " equals...");
            cont = false;
        }
        
        else if(counter + 1 == x.size())
        {
            System.out.println("\nCannot end a variable declaration with a "
                    + "variable...");
            cont = false;
        }
        
        else
        {
            cont = true;  
            counter++;
        }          
    }
    
    public void token_equals(ArrayList<String> x)
    //Precondition:
    //Postconditiion: Ensures the legality of the token ordering in relation to 
    //the 'EQUALS' token.
    {
        if(counter + 1 < x.size()&&!x.get(counter + 1).contains("MINUS")&&
                !x.get(counter + 1).contains("INTEGER")&& 
                !x.get(counter + 1).contains("LEFT_PARENTHESIS")&&
                !x.get(counter + 1).contains("ZERO"))
        {
            System.out.println("\nEither a minus symbol, an integer or a left "
                    + "parenthesis must follow an integer variable "
                    + "declaration...");
            cont = false;
        }
        
        else if(counter + 1 == x.size())
        {
            System.out.println("\nCannot end a variable declaration with an "
                    + "equals...");
            cont = false;
        }
        
        else
        {
            if(counter + 1 < x.size() && x.get(counter + 1).contains("ZERO"))
                leading_zero = true;
            
            else if(counter + 1 < x.size() && x.get(counter + 1).contains("MINUS"))
                negative = true;
            
            cont = true;
            counter++;
        }
    }
    
    public void token_minus(ArrayList<String> x)
    //Precondition:
    //Postconditiion: Ensures the legality of the token ordering in relation to 
    //the 'MINUS' token.
    {
        if(counter + 1 < x.size()&&!x.get(counter + 1).contains("INTEGER")&&
                !x.get(counter + 1).contains("MINUS")&&
                !x.get(counter + 1).contains("LEFT_PARENTHESIS")&&
                !x.get(counter + 1).contains("ZERO"))
        {
            System.out.println("\nOnly an integer, a minus symbol or a left "
                    + "parenthesis symbol can follow...");
            cont = false;
        }
        
        else if(counter + 1 == x.size())
        {
            System.out.println("\nCannot end a variable declaration with a left "
                    + "parenthesis...");
            cont = false;
        }
        
        else
        {
            if(counter + 1 < x.size()&& negative == true && 
                    x.get(counter + 1).contains("ZERO"))
            {
                System.out.println("\nNegative zero does not exist...");
                cont = false;
            }
            
            else
            {                
                cont = true;
                counter++;
            }
        }
    }
    
    public void token_operator(ArrayList<String> x)
    //Precondition:
    //Postconditiion: Ensures the legality of the token ordering in relation to 
    //the 'PLUS', 'MULTIPLY' and 'DIVIDE' tokens.
    {
        if(counter + 1 < x.size()&&!x.get(counter + 1).contains("INTEGER") && 
            !x.get(counter + 1).contains("MINUS") && 
            !x.get(counter + 1).contains("LEFT_PARENTHESIS")&&
            !x.get(counter + 1).contains("ZERO"))
        {
            System.out.println("\nAn operator can only be followed by an "
                        + "integer, a minus sign, or a left parenthesis...");
            cont = false;
        }
        
        else if(counter + 1 == x.size())
        {
            System.out.println("\nCannot end a variable declaration with an "
                    + "operator...");
            cont = false;
        }
        
        else
        {
            cont = true;
            counter++;
        }
    }
    
    public void token_left_parenthesis(ArrayList<String> x)
    //Precondition:
    //Postconditiion: Ensures the legality of the token ordering in relation to 
    //the 'LEFT_PARENTHESIS' token.
    {
        if(counter + 1 < x.size()&&!x.get(counter + 1).contains("INTEGER") &&
                !x.get(counter + 1).contains("ZERO")&&
                !x.get(counter + 1).contains("MINUS")&&
                !x.get(counter + 1).contains("LEFT_PARENTHESIS"))
        {
            System.out.println("\nOnly an integer or a minus sign can follow a "
                        + "left parenthesis...");
            cont = false;
        }
        
        else if(counter + 1 == x.size())
        {
            System.out.println("\nCannot end a variable declaration with a left"
                    + " parenthesis...");
            cont = false;
        }
        
        else
        {
            parenthesis_closed.add("LEFT");
            cont = true;
            counter++;
        }
    }
    public void token_right_parenthesis(ArrayList<String> x)
    //Precondition:
    //Postconditiion: Ensures the legality of the token ordering in relation to 
    //the 'RIGHT_PARENTHESIS' token.
    {
        if(counter + 1 < x.size()&&!x.get(counter + 1).contains("PLUS") &&
            !x.get(counter + 1).contains("MINUS") &&
            !x.get(counter + 1).contains("DIVIDE") &&
            !x.get(counter + 1).contains("MULTIPLY")&&
            !x.get(counter + 1).contains("RIGHT_PARENTHESIS")&&
            !x.get(counter + 1).contains("NEW LINE"))
        {
            System.out.println("\nA right parenthesis can be followed by any"
                        + " operator or a new line...");
            cont = false;
        }
        
        else
        {
            if(parenthesis_closed.isEmpty())
            {
                System.out.println("\nMust have a opening parenthesis before adding"
                        + " a closing parenthesis...");
                cont = false;
            }
            
            else
            {
                parenthesis_closed.pop();
                cont = true;
                counter++;
            }
        }
    }
    
    public void token_integer(ArrayList<String> x)
    //Precondition:
    //Postconditiion: Ensures the legality of the token ordering in relation to 
    //the 'INTEGER' token.
    {
        if(counter + 1 < x.size()&&!x.get(counter + 1).contains("MINUS")&&
                !x.get(counter + 1).contains("PLUS")&&
                !x.get(counter + 1).contains("MULTIPLY")&&
                !x.get(counter + 1).contains("DIVIDE")&&
                !x.get(counter + 1).contains("INTEGER")&&
                !x.get(counter + 1).contains("LEFT_PARENTHESIS")&&
                !x.get(counter + 1).contains("RIGHT_PARENTHESIS")&&
                !x.get(counter + 1).contains("NEW LINE")&&
                !x.get(counter + 1).contains("ZERO"))
        {
            System.out.println("\nAn integer can be followed by any operator, "
                    + "another integer, a left or right parenthesis, or a new "
                    + "line token...");
            cont = false;
        }
        
        else
        {
            cont = true;
            counter++;
        }
    }
    
    public void token_zero(ArrayList<String> x)
    //Precondition:
    //Postconditiion: Ensures the legality of the token ordering in relation to 
    //the 'ZERO' token.
    {
        if(counter + 1 < x.size()&&!x.get(counter + 1).contains("INTEGER")&&
                !x.get(counter + 1).contains("RIGHT_PARENTHESIS")&&
                !x.get(counter + 1).contains("PLUS")&&
                !x.get(counter + 1).contains("MINUS")&&
                !x.get(counter + 1).contains("MULTIPLY")&&
                !x.get(counter + 1).contains("DIVIDE")&&
                !x.get(counter + 1).contains("NEW LINE"))
        {
            System.out.println("\nA zero may be followed by an integer, right "
                    + "parenthesis, operator or new line token...");
            cont = false;
        }
        
        else
        {
            if(leading_zero == true && counter + 1 < x.size()&&
                    x.get(counter + 1).contains("INTEGER"))
            {
                System.out.println("\nAn integer should not have a leading zero...");
                cont = false;                
            }
            
            else
            {
                cont = true;
                counter++;
            }
        }
    }
    
    public void token_new_line(ArrayList<String> x)
    //Precondition:
    //Postconditiion: Ensures the legality of the token ordering in relation to 
    //the 'NEW LINE' token.
    {
        if(counter + 1 < x.size()&&!x.get(counter + 1).contains("VARIABLE"))
        {
            System.out.println("\nA variable must follow a new line...");
            cont = false;
        }
        
        else if(counter + 1 == x.size())
        {
            System.out.println("\nCannot end a variable declaration with a new "
                    + "line...");
            cont = false;
        }
        
        else
        {
            cont = true;
            leading_zero = false;
            counter++;
        }
    }   
}
